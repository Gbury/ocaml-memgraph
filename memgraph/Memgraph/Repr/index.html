<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Repr (memgraph.Memgraph.Repr)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">memgraph</a> &#x00BB; <a href="../index.html">Memgraph</a> &#x00BB; Repr</nav><header class="odoc-preamble"><h1>Module <code><span>Memgraph.Repr</span></code></h1><p>Representation of ocaml values</p><p>This module aims at given a way to inspect the memory layout of ocaml values by providing some type to represent memory layouts, and some functions to convert arbitrary ocaml values into their explicit memory representation.</p></header><nav class="odoc-toc"><ul><li><a href="#type-definitions">Type definitions</a></li><li><a href="#manipulating-values">Manipulating values</a></li><li><a href="#creating-values">Creating values</a></li></ul></nav><div class="odoc-content"><h3 id="type-definitions"><a href="#type-definitions" class="anchor"></a>Type definitions</h3><div class="odoc-spec"><div class="spec type anchored" id="type-tag"><a href="#type-tag" class="anchor"></a><code><span><span class="keyword">type</span> tag</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>Ocaml tags</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-addr"><a href="#type-addr" class="anchor"></a><code><span><span class="keyword">type</span> addr</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>Abstract addresses, used for sharing</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-closinfo"><a href="#type-closinfo" class="anchor"></a><code><span><span class="keyword">type</span> closinfo</span><span> = </span><span>{</span></code><ol><li id="type-closinfo.arity" class="def record field anchored"><a href="#type-closinfo.arity" class="anchor"></a><code><span>arity : int;</span></code></li><li id="type-closinfo.start_of_env" class="def record field anchored"><a href="#type-closinfo.start_of_env" class="anchor"></a><code><span>start_of_env : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Contents of the closure info field, stored for each closure in a set of closures.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-block"><a href="#type-block" class="anchor"></a><code><span><span class="keyword">type</span> block</span><span> = <span class="keyword">private</span> </span><span>{</span></code><ol><li id="type-block.addr" class="def record field anchored"><a href="#type-block.addr" class="anchor"></a><code><span>addr : <a href="#type-addr">addr</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>unique int to preserve sharing</p><span class="comment-delim">*)</span></div></li><li id="type-block.tag" class="def record field anchored"><a href="#type-block.tag" class="anchor"></a><code><span>tag : <a href="#type-tag">tag</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block tag</p><span class="comment-delim">*)</span></div></li><li id="type-block.data" class="def record field anchored"><a href="#type-block.data" class="anchor"></a><code><span>data : <a href="#type-data">data</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Block contents</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Represent OCaml blocks.</p><ul><li>tag is the ocaml tag in the block header.</li><li>data is a high-level representation of the fields of the block.</li><li>addr is additional information used to keep track of sharing between values.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-data"><a href="#type-data" class="anchor"></a><code><span><span class="keyword">and</span> data</span><span> = </span></code><ol><li id="type-data.Abstract" class="def variant constructor anchored"><a href="#type-data.Abstract" class="anchor"></a><code><span>| </span><span><span class="constructor">Abstract</span></span></code></li><li id="type-data.Block" class="def variant constructor anchored"><a href="#type-data.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <span><span>[ `Block ]</span> <a href="#type-cell">cell</a></span></span></code></li><li id="type-data.Fields" class="def variant constructor anchored"><a href="#type-data.Fields" class="anchor"></a><code><span>| </span><span><span class="constructor">Fields</span> <span class="keyword">of</span> <span><span><span>[ `Inline ]</span> <a href="#type-cell">cell</a></span> array</span></span></code></li></ol></div><div class="spec-doc"><p>To have a high-level representation of a block's fields, we distinguish three cases:</p><ul><li>some block are abstract and thus their contents cannot be inspected</li><li>the block contain a single big value (typically a string and/or a float)</li><li>the block contains an array of values.</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cell"><a href="#type-cell" class="anchor"></a><code><span><span class="keyword">and</span> <span>_ cell</span></span><span> = </span></code><ol><li id="type-cell.Int" class="def variant constructor anchored"><a href="#type-cell.Int" class="anchor"></a><code><span>| </span><span><span class="constructor">Int</span> : int <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Inline <span>| `Direct</span> ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Integers</p><span class="comment-delim">*)</span></div></li><li id="type-cell.Pointer" class="def variant constructor anchored"><a href="#type-cell.Pointer" class="anchor"></a><code><span>| </span><span><span class="constructor">Pointer</span> : <a href="#type-addr">addr</a> <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Inline <span>| `Direct</span> ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Pointers to some block</p><span class="comment-delim">*)</span></div></li><li id="type-cell.External" class="def variant constructor anchored"><a href="#type-cell.External" class="anchor"></a><code><span>| </span><span><span class="constructor">External</span> : <span class="xref-unresolved">Stdlib</span>.Nativeint.t <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Inline ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Out of heap pointer</p><span class="comment-delim">*)</span></div></li><li id="type-cell.String" class="def variant constructor anchored"><a href="#type-cell.String" class="anchor"></a><code><span>| </span><span><span class="constructor">String</span> : string <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Block ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>String</p><span class="comment-delim">*)</span></div></li><li id="type-cell.Double" class="def variant constructor anchored"><a href="#type-cell.Double" class="anchor"></a><code><span>| </span><span><span class="constructor">Double</span> : float <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Block <span>| `Inline</span> ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A float</p><span class="comment-delim">*)</span></div></li><li id="type-cell.Infix" class="def variant constructor anchored"><a href="#type-cell.Infix" class="anchor"></a><code><span>| </span><span><span class="constructor">Infix</span> : <span><span>[ `Inline ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An infix header (used in closures)</p><span class="comment-delim">*)</span></div></li><li id="type-cell.Closinfo" class="def variant constructor anchored"><a href="#type-cell.Closinfo" class="anchor"></a><code><span>| </span><span><span class="constructor">Closinfo</span> : <a href="#type-closinfo">closinfo</a> <span class="arrow">&#45;&gt;</span> <span><span>[&lt; `Inline ]</span> <a href="#type-cell">cell</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Closure info field</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>The actual type of memory cells containing concrete values. There are actually three type of cells:</p><ul><li><code>`Direct</code> cells are values that can be found in ocaml variables</li><li><code>`Inline</code> cells are values that can be found in a block's field array</li><li><code>`Block</code> cells are &quot;big&quot; values that take a whole block</li></ul><p>Obviously, some constructors can build more than one type of cells.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-pblock"><a href="#type-pblock" class="anchor"></a><code><span><span class="keyword">type</span> pblock</span><span> = <span class="keyword">private</span> </span><span>{</span></code><ol><li id="type-pblock.block" class="def record field anchored"><a href="#type-pblock.block" class="anchor"></a><code><span>block : <a href="#type-block">block</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The block being pointed at</p><span class="comment-delim">*)</span></div></li><li id="type-pblock.offset" class="def record field anchored"><a href="#type-pblock.offset" class="anchor"></a><code><span>offset : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The offset in the block (used in mutually rec closures)</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>This represents what is pointed at by a pointer. This is useful considering that an ocaml value can point at a closure within a set of closures, and thus point in the middle of an ocaml value (since there is an infix header, the value being pointed to is also an ocaml value, but things are easier to represent this way).</p></div></div><h3 id="manipulating-values"><a href="#manipulating-values" class="anchor"></a>Manipulating values</h3><div class="odoc-spec"><div class="spec value anchored" id="val-follow"><a href="#val-follow" class="anchor"></a><code><span><span class="keyword">val</span> follow : <span><a href="#type-addr">addr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-pblock">pblock</a></span></code></div><div class="spec-doc"><p>Follow a pointer.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-walk"><a href="#val-walk" class="anchor"></a><code><span><span class="keyword">val</span> walk : <span><span>(<span><a href="#type-pblock">pblock</a> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pblock">pblock</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Apply the given function to a block, and all the blocks it points to (recursively). Each block is visited exactly once (the order is left unspecified though).</p></div></div><h3 id="creating-values"><a href="#creating-values" class="anchor"></a>Creating values</h3><div class="odoc-spec"><div class="spec value anchored" id="val-repr"><a href="#val-repr" class="anchor"></a><code><span><span class="keyword">val</span> repr : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Direct ]</span> <a href="#type-cell">cell</a></span></span></code></div><div class="spec-doc"><p>Get the representation of a direct ocaml value.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-context"><a href="#type-context" class="anchor"></a><code><span><span class="keyword">type</span> context</span><span> = </span><span>{</span></code><ol><li id="type-context.mk" class="def record field anchored"><a href="#type-context.mk" class="anchor"></a><code><span>mk : 'a. <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>[ `Direct ]</span> <a href="#type-cell">cell</a></span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A type containing a function to create cells.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-context"><a href="#val-context" class="anchor"></a><code><span><span class="keyword">val</span> context : <span><span>(<span><a href="#type-context">context</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Allow to use the same context for creating values, i.e. all values created with <code>context.mk</code> will correctly identify shared values between translated values.</p></div></div></div></body></html>